{"ast":null,"code":"'use strict';\n\nconst util = require('./util');\n\nconst buildOptions = require('./util').buildOptions;\n\nconst xmlNode = require('./xmlNode');\n\nconst TagType = {\n  OPENING: 1,\n  CLOSING: 2,\n  SELF: 3,\n  CDATA: 4\n};\nconst regx = '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'.replace(/NAME/g, util.nameRegexp); //const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n//polyfill\n\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\n\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false,\n  //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true,\n  //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  tagValueProcessor: function (a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function (a, attrName) {\n    return a;\n  },\n  stopNodes: [] //decodeStrict: false,\n\n};\nexports.defaultOptions = defaultOptions;\nconst props = ['attributeNamePrefix', 'attrNodeName', 'textNodeName', 'ignoreAttributes', 'ignoreNameSpace', 'allowBooleanAttributes', 'parseNodeValue', 'parseAttributeValue', 'arrayMode', 'trimValues', 'cdataTagName', 'cdataPositionChar', 'tagValueProcessor', 'attrValueProcessor', 'parseTrueNumberOnly', 'stopNodes'];\nexports.props = props;\n\nconst getTraversalObj = function (xmlData, options) {\n  options = buildOptions(options, defaultOptions, props); //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n\n  xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, ''); //Remove  comments\n\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  const tagsRegx = new RegExp(regx, 'g');\n  let tag = tagsRegx.exec(xmlData);\n  let nextTag = tagsRegx.exec(xmlData);\n\n  while (tag) {\n    const tagType = checkForTagType(tag);\n\n    if (tagType === TagType.CLOSING) {\n      //add parsed data to parent node\n      if (currentNode.parent && tag[12]) {\n        currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue(tag, options, currentNode.parent.tagname);\n      }\n\n      if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n        currentNode.child = [];\n\n        if (currentNode.attrsMap == undefined) {\n          currentNode.attrsMap = {};\n        }\n\n        currentNode.val = xmlData.substr(currentNode.startIndex + 1, tag.index - currentNode.startIndex - 1);\n      }\n\n      currentNode = currentNode.parent;\n    } else if (tagType === TagType.CDATA) {\n      if (options.cdataTagName) {\n        //add cdata node\n        const childNode = new xmlNode(options.cdataTagName, currentNode, tag[3]);\n        childNode.attrsMap = buildAttributesMap(tag[8], options);\n        currentNode.addChild(childNode); //for backtracking\n\n        currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar; //add rest value to parent node\n\n        if (tag[12]) {\n          currentNode.val += processTagValue(tag, options);\n        }\n      } else {\n        currentNode.val = (currentNode.val || '') + (tag[3] || '') + processTagValue(tag, options);\n      }\n    } else if (tagType === TagType.SELF) {\n      if (currentNode && tag[12]) {\n        currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tag, options);\n      }\n\n      const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, '');\n\n      if (tag[8] && tag[8].length > 0) {\n        tag[8] = tag[8].substr(0, tag[8].length - 1);\n      }\n\n      childNode.attrsMap = buildAttributesMap(tag[8], options);\n      currentNode.addChild(childNode);\n    } else {\n      //TagType.OPENING\n      const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, processTagValue(tag, options));\n\n      if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n        childNode.startIndex = tag.index + tag[1].length;\n      }\n\n      childNode.attrsMap = buildAttributesMap(tag[8], options);\n      currentNode.addChild(childNode);\n      currentNode = childNode;\n    }\n\n    tag = nextTag;\n    nextTag = tagsRegx.exec(xmlData);\n  }\n\n  return xmlObj;\n};\n\nfunction processTagValue(parsedTags, options, parentTagName) {\n  const tagName = parsedTags[7] || parentTagName;\n  let val = parsedTags[12];\n\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);\n  }\n\n  return val;\n}\n\nfunction checkForTagType(match) {\n  if (match[4] === ']]>') {\n    return TagType.CDATA;\n  } else if (match[10] === '/') {\n    return TagType.CLOSING;\n  } else if (typeof match[8] !== 'undefined' && match[8].substr(match[8].length - 1) === '/') {\n    return TagType.SELF;\n  } else {\n    return TagType.OPENING;\n  }\n}\n\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n\n  return tagname;\n}\n\nfunction parseValue(val, shouldParse, parseTrueNumberOnly) {\n  if (shouldParse && typeof val === 'string') {\n    let parsed;\n\n    if (val.trim() === '' || isNaN(val)) {\n      parsed = val === 'true' ? true : val === 'false' ? false : val;\n    } else {\n      if (val.indexOf('0x') !== -1) {\n        //support hexa decimal\n        parsed = Number.parseInt(val, 16);\n      } else if (val.indexOf('.') !== -1) {\n        parsed = Number.parseFloat(val);\n        val = val.replace(/0+$/, \"\");\n      } else {\n        parsed = Number.parseInt(val, 10);\n      }\n\n      if (parseTrueNumberOnly) {\n        parsed = String(parsed) === val ? parsed : val;\n      }\n    }\n\n    return parsed;\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n} //TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\n\n\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' '); //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n\n    const attrs = {};\n\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(matches[i][4], options.parseAttributeValue, options.parseTrueNumberOnly);\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n\n    return attrs;\n  }\n}\n\nexports.getTraversalObj = getTraversalObj;","map":{"version":3,"sources":["/Users/cristianoandradre/Documents/treinamentoAWS/blogfinal/blogfinal/blogfinal/node_modules/fast-xml-parser/src/xmlstr2xmlnode.js"],"names":["util","require","buildOptions","xmlNode","TagType","OPENING","CLOSING","SELF","CDATA","regx","replace","nameRegexp","Number","parseInt","window","parseFloat","defaultOptions","attributeNamePrefix","attrNodeName","textNodeName","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","arrayMode","trimValues","cdataTagName","cdataPositionChar","tagValueProcessor","a","tagName","attrValueProcessor","attrName","stopNodes","exports","props","getTraversalObj","xmlData","options","xmlObj","currentNode","tagsRegx","RegExp","tag","exec","nextTag","tagType","checkForTagType","parent","val","getValue","processTagValue","tagname","length","includes","child","attrsMap","undefined","substr","startIndex","index","childNode","buildAttributesMap","addChild","parsedTags","parentTagName","trim","parseValue","parseTrueNumberOnly","match","resolveNameSpace","tags","split","prefix","charAt","shouldParse","parsed","isNaN","indexOf","String","isExist","attrsRegx","attrStr","matches","getAllMatches","len","attrs","i","Object","keys","attrCollection"],"mappings":"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","sourcesContent":["'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst xmlNode = require('./xmlNode');\nconst TagType = {OPENING: 1, CLOSING: 2, SELF: 3, CDATA: 4};\nconst regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n  .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false, //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true, //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  tagValueProcessor: function(a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function(a, attrName) {\n    return a;\n  },\n  stopNodes: []\n  //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'ignoreNameSpace',\n  'allowBooleanAttributes',\n  'parseNodeValue',\n  'parseAttributeValue',\n  'arrayMode',\n  'trimValues',\n  'cdataTagName',\n  'cdataPositionChar',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'parseTrueNumberOnly',\n  'stopNodes'\n];\nexports.props = props;\n\nconst getTraversalObj = function(xmlData, options) {\n  options = buildOptions(options, defaultOptions, props);\n  //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n  xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, ''); //Remove  comments\n\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n\n  const tagsRegx = new RegExp(regx, 'g');\n  let tag = tagsRegx.exec(xmlData);\n  let nextTag = tagsRegx.exec(xmlData);\n  while (tag) {\n    const tagType = checkForTagType(tag);\n\n    if (tagType === TagType.CLOSING) {\n      //add parsed data to parent node\n      if (currentNode.parent && tag[12]) {\n        currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue(tag, options, currentNode.parent.tagname);\n      }\n      if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n        currentNode.child = []\n        if (currentNode.attrsMap == undefined) { currentNode.attrsMap = {}}\n        currentNode.val = xmlData.substr(currentNode.startIndex + 1, tag.index - currentNode.startIndex - 1)\n      }\n      currentNode = currentNode.parent;\n    } else if (tagType === TagType.CDATA) {\n      if (options.cdataTagName) {\n        //add cdata node\n        const childNode = new xmlNode(options.cdataTagName, currentNode, tag[3]);\n        childNode.attrsMap = buildAttributesMap(tag[8], options);\n        currentNode.addChild(childNode);\n        //for backtracking\n        currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n        //add rest value to parent node\n        if (tag[12]) {\n          currentNode.val += processTagValue(tag, options);\n        }\n      } else {\n        currentNode.val = (currentNode.val || '') + (tag[3] || '') + processTagValue(tag, options);\n      }\n    } else if (tagType === TagType.SELF) {\n      if (currentNode && tag[12]) {\n        currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tag, options);\n      }\n\n      const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, '');\n      if (tag[8] && tag[8].length > 0) {\n        tag[8] = tag[8].substr(0, tag[8].length - 1);\n      }\n      childNode.attrsMap = buildAttributesMap(tag[8], options);\n      currentNode.addChild(childNode);\n    } else {\n      //TagType.OPENING\n      const childNode = new xmlNode(\n        options.ignoreNameSpace ? tag[7] : tag[5],\n        currentNode,\n        processTagValue(tag, options)\n      );\n      if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n        childNode.startIndex=tag.index + tag[1].length\n      }\n      childNode.attrsMap = buildAttributesMap(tag[8], options);\n      currentNode.addChild(childNode);\n      currentNode = childNode;\n    }\n\n    tag = nextTag;\n    nextTag = tagsRegx.exec(xmlData);\n  }\n\n  return xmlObj;\n};\n\nfunction processTagValue(parsedTags, options, parentTagName) {\n  const tagName = parsedTags[7] || parentTagName;\n  let val = parsedTags[12];\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);\n  }\n\n  return val;\n}\n\nfunction checkForTagType(match) {\n  if (match[4] === ']]>') {\n    return TagType.CDATA;\n  } else if (match[10] === '/') {\n    return TagType.CLOSING;\n  } else if (typeof match[8] !== 'undefined' && match[8].substr(match[8].length - 1) === '/') {\n    return TagType.SELF;\n  } else {\n    return TagType.OPENING;\n  }\n}\n\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\nfunction parseValue(val, shouldParse, parseTrueNumberOnly) {\n  if (shouldParse && typeof val === 'string') {\n    let parsed;\n    if (val.trim() === '' || isNaN(val)) {\n      parsed = val === 'true' ? true : val === 'false' ? false : val;\n    } else {\n      if (val.indexOf('0x') !== -1) {\n        //support hexa decimal\n        parsed = Number.parseInt(val, 16);\n      } else if (val.indexOf('.') !== -1) {\n        parsed = Number.parseFloat(val);\n        val = val.replace(/0+$/,\"\");\n      } else {\n        parsed = Number.parseInt(val, 10);\n      }\n      if (parseTrueNumberOnly) {\n        parsed = String(parsed) === val ? parsed : val;\n      }\n    }\n    return parsed;\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(\n            matches[i][4],\n            options.parseAttributeValue,\n            options.parseTrueNumberOnly\n          );\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\n\nexports.getTraversalObj = getTraversalObj;\n"]},"metadata":{},"sourceType":"script"}